"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.DEFAULT_COOKIE_PATH = exports.DEFAULT_COOKIE_NAME = void 0;
const crypto_1 = require("./crypto");
const session_1 = require("./session");
require("./typings");
exports.DEFAULT_COOKIE_NAME = 'Session';
exports.DEFAULT_COOKIE_PATH = '/';
const plugin = async (fastify, options = {}) => {
    const { key, secret, salt, cookieName = exports.DEFAULT_COOKIE_NAME, cookie: cookieOptions = {}, store, crypto = crypto_1.HMAC, saveUninitialized = true, logBindings = { plugin: 'fastify-session' }, } = options;
    if (!key && !secret) {
        throw new Error('key or secret must specified');
    }
    if (!crypto) {
        throw new Error('invalid crypto specified');
    }
    if (!cookieOptions.path) {
        cookieOptions.path = exports.DEFAULT_COOKIE_PATH;
    }
    const secretKeys = crypto.deriveSecretKeys(key, secret, salt);
    session_1.Session.configure({ cookieOptions, secretKeys, store, crypto });
    fastify.decorateRequest('session', null);
    async function destroySession() {
        if (!this.session) {
            return;
        }
        await this.session.destroy();
    }
    fastify.decorateRequest('destroySession', destroySession);
    // decode/create a session for every request
    fastify.addHook('onRequest', async (request) => {
        const { cookies, log } = request;
        const bindings = { ...logBindings, hook: 'onRequest' };
        const cookie = cookies[cookieName];
        if (!cookie) {
            request.session = new session_1.Session();
            log.debug({ ...bindings, sessionId: request.session.id }, 'There was no cookie, created an empty session');
            return;
        }
        try {
            log.debug(bindings, 'Found an existing cookie, attempting to decode session ...');
            request.session = await session_1.Session.fromCookie(cookie);
            log.info({ ...bindings, sessionId: request.session.id }, 'Session successfully decoded');
            return;
        }
        catch (err) {
            request.session = new session_1.Session();
            log.warn({ ...bindings, err, sessionId: request.session.id }, `Failed to decode existing cookie, created an empty session`);
            return;
        }
    });
    // encode a cookie
    fastify.addHook('onSend', async (request, reply) => {
        const { session, log } = request;
        const bindings = { ...logBindings, hook: 'onSend' };
        if (!session) {
            log.debug(bindings, 'There was no session, leaving it as is');
            return;
        }
        else if (!saveUninitialized && !Object.keys(session.data).length) {
            log.debug({ ...bindings, sessionId: session.id }, "Created session is empty and won't be saved, leaving it as is");
            return;
        }
        else if (!session.changed && !session.created && !session.rotated) {
            log.debug({ ...bindings, sessionId: session.id }, 'The existing session was not changed, leaving it as is');
            return;
        }
        else if (session.deleted) {
            reply.setCookie(cookieName, '', {
                ...cookieOptions,
                ...session[session_1.kCookieOptions],
                expires: new Date(0),
                maxAge: 0,
            });
            log.info({ ...bindings, sessionId: session.id }, 'Deleted session');
            return;
        }
        if (session.created || session.changed) {
            log.debug({ ...bindings, sessionId: session.id }, `About to save a ${session.created ? 'created' : 'changed'} session, saving ...`);
            await session.save();
            log.info({ ...bindings, sessionId: session.id }, `${session.created ? 'Created' : 'Changed'} session successfully saved`);
        }
        reply.setCookie(cookieName, await session.toCookie(), { ...cookieOptions, ...session[session_1.kCookieOptions] });
    });
};
exports.plugin = plugin;
