"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HMAC = exports.Hmac = void 0;
const crypto_1 = __importDefault(require("crypto"));
const utils_1 = require("../utils");
class Hmac {
    constructor(encoding = 'base64', algorithm = 'sha256') {
        this.protocol = '/hmac';
        this.stateless = false;
        this.encoding = encoding;
        this.algorithm = algorithm;
    }
    deriveSecretKeys(key, secret) {
        if (key) {
            return sanitizeSecretKeys(key, this.encoding);
        }
        else if (secret) {
            return [(0, utils_1.asBuffer)(secret)];
        }
        throw (0, utils_1.createError)('SecretKeyDerivation', 'Failed to derive keys from options');
    }
    sealMessage(message, secretKey) {
        return (message.toString(this.encoding) +
            utils_1.CRYPTO_SPLIT_CHAR +
            crypto_1.default.createHmac(this.algorithm, secretKey).update(message).digest(this.encoding).replace(/\=+$/, ''));
    }
    unsealMessage(message, secretKeys) {
        const splitCharIndex = message.lastIndexOf(utils_1.CRYPTO_SPLIT_CHAR);
        if (splitCharIndex === -1) {
            throw (0, utils_1.createError)('MalformedMessageError', 'The message is malformed');
        }
        const cleartext = Buffer.from(message.slice(0, splitCharIndex), this.encoding);
        // const signature = Buffer.from(message.slice(splitCharIndex + 1), this.encoding);
        // if (signature.length !== 64) {
        //   throw createError('SignatureLengthError', 'The signature does not have the required length');
        // }
        let rotated = false;
        // const messageBuffer = Buffer.from(message);
        const success = secretKeys.some((secretKey, index) => {
            const signedBuffer = Buffer.from(this.sealMessage(cleartext, secretKey));
            const messageBuffer = Buffer.alloc(signedBuffer.length);
            messageBuffer.write(message);
            const verified = crypto_1.default.timingSafeEqual(signedBuffer, messageBuffer);
            rotated = verified && index > 0;
            return verified;
        });
        if (!success) {
            throw (0, utils_1.createError)('VerifyError', 'Unable to verify');
        }
        return { buffer: cleartext, rotated };
    }
}
exports.Hmac = Hmac;
exports.HMAC = new Hmac();
const sanitizeSecretKeys = (key, encoding = 'base64') => {
    const secretKeys = Array.isArray(key) ? key.map((v) => (0, utils_1.asBuffer)(v, encoding)) : [(0, utils_1.asBuffer)(key, encoding)];
    return secretKeys;
};
