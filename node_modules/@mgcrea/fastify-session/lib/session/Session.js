"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = exports.kOtherOptions = exports.kSessionCrypto = exports.kSessionStore = exports.kSecretKeys = exports.kExpiry = exports.kCookieOptions = exports.kSessionData = void 0;
const nanoid_1 = require("nanoid");
const Hmac_1 = require("../crypto/Hmac");
const store_1 = require("../store");
const utils_1 = require("../utils");
exports.kSessionData = Symbol('kSessionData');
exports.kCookieOptions = Symbol('kCookieOptions');
exports.kExpiry = Symbol('kExpiry');
exports.kSecretKeys = Symbol('kSecretKeys');
exports.kSessionStore = Symbol('kSessionStore');
exports.kSessionCrypto = Symbol('kSessionCrypto');
exports.kOtherOptions = Symbol('kOtherOptions');
class Session {
    constructor(data, options = {}) {
        this.created = false;
        this.rotated = false;
        this.changed = false;
        this.deleted = false;
        const { id = (0, nanoid_1.nanoid)(), ...cookieOptions } = options;
        this[exports.kSessionData] = data || {};
        this[exports.kCookieOptions] = { ...Session[exports.kCookieOptions], ...cookieOptions };
        this.id = id;
        this.created = !data;
        this.touch();
    }
    static configure({ secretKeys, crypto = Hmac_1.HMAC, store = store_1.MEMORY_STORE, cookieOptions = {}, }) {
        Session[exports.kSecretKeys] = secretKeys;
        Session[exports.kSessionCrypto] = crypto;
        Session[exports.kSessionStore] = store;
        Session[exports.kCookieOptions] = cookieOptions;
    }
    // Decoding
    static async fromCookie(cookie) {
        const { buffer: cleartext, rotated } = Session[exports.kSessionCrypto].unsealMessage(cookie, Session[exports.kSecretKeys]);
        // Stateless sessions have the whole session data encrypted as the cookie
        if (Session[exports.kSessionCrypto].stateless) {
            const session = new Session(JSON.parse(cleartext.toString()));
            session.rotated = rotated;
            return session;
        }
        // Stateful sessions have ids signed as the cookie
        const sessionId = cleartext.toString();
        const result = await Session[exports.kSessionStore].get(sessionId);
        if (!result) {
            throw (0, utils_1.createError)('SessionNotFound', 'did not found a matching session in the store');
        }
        const [data, expiry] = result;
        if (expiry && expiry <= Date.now()) {
            throw (0, utils_1.createError)('ExpiredSession', 'the store returned an expired session');
        }
        const session = new Session(data, { id: sessionId, expires: expiry ? new Date(expiry) : undefined });
        session.rotated = rotated;
        return session;
    }
    // Encoding
    async toCookie() {
        const buffer = Buffer.from(Session[exports.kSessionCrypto].stateless ? JSON.stringify({ ...this[exports.kSessionData], id: this.id }) : this.id);
        return Session[exports.kSessionCrypto].sealMessage(buffer, Session[exports.kSecretKeys][0]);
    }
    async touch() {
        if (Session[exports.kSessionCrypto].stateless) {
            return;
        }
        const { maxAge = Session[exports.kCookieOptions].maxAge, expires = Session[exports.kCookieOptions].expires } = this[exports.kCookieOptions];
        if (maxAge) {
            const expiry = Date.now() + maxAge * 1000;
            // Get the longest lifespan between "expires" and "maxAge"
            this[exports.kExpiry] = expires ? Math.max(expires.getTime(), expiry) : expiry;
        }
        else if (expires) {
            this[exports.kExpiry] = expires.getTime();
        }
        if (!this.created && Session[exports.kSessionStore].touch) {
            await Session[exports.kSessionStore].touch(this.id, this[exports.kExpiry]);
        }
    }
    async destroy() {
        this.delete();
        if (Session[exports.kSessionCrypto].stateless) {
            return;
        }
        await Session[exports.kSessionStore].destroy(this.id);
    }
    async save() {
        if (Session[exports.kSessionCrypto].stateless) {
            return;
        }
        // Save session to store with store-handled expiry
        await Session[exports.kSessionStore].set(this.id, this[exports.kSessionData], this[exports.kExpiry]);
    }
    get data() {
        return this[exports.kSessionData];
    }
    get expiry() {
        return this[exports.kExpiry];
    }
    // Lifecycle
    get(key) {
        return this[exports.kSessionData][key];
    }
    set(key, value) {
        this.changed = true;
        this[exports.kSessionData][key] = value;
    }
    delete() {
        this.changed = true;
        this.deleted = true;
    }
    get options() {
        return this[exports.kCookieOptions];
    }
    setOptions(options) {
        Object.assign(this[exports.kCookieOptions], options);
    }
}
exports.Session = Session;
